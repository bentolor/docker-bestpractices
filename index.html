<!doctype html>
<html lang="de">

	<head>
		<meta charset="utf-8">

		<title>Building, Running &amp; Maintaining Containers &dash; Best Practices</title>

		<meta name="description" content="Eine Einführung in den Einsatz von docker für Java-Anwendungen">
		<meta name="author" content="Benjamin Schmid">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="plugin/highlight/zenburn.css">

		<!-- Custom, overriding CSS -->
		<link rel="stylesheet" href="docker.css">
	</head>

	<body>

		<div id="logo"><img src="img/nagarro-logo.svg"></img></div>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


				<section>
					<div id="title">
					<h1 style="margin: 10px">Building, Running <br/>&amp; Maintaining Containers</h1>
					<h3>Best Practices exemplified by Docker</h3>

					<!-- Profil-Karten -->
					    <div class="profile">
								<div class="profile-sidebar">
									<div class="profile-userpic">
										<img data-src="img/BenjaminSchmid.jpg" class="img-responsive" alt="">
									</div>
									<div class="profile-usertitle">
										<div class="profile-usertitle-name">
											Benjamin <br/>Schmid
										</div>
										<div class="profile-usertitle-job">
											
										</div>
									</div>
							</div>
							<div class="profile-content">
				   				<a href="https://twitter.com/bentolor">@bentolor</a>
	            			</div>
						</div>
					</div>

					<div id="footer" style="display: none;">
						<div id="logo">
							<img src="img/nagarro-logo.svg" />
						</div>
						<div id="helpfooter">
							? für Hilfe, S für Folien-Notizen
						</div>
						<div id="version">
							21. September 2021
						</div>
						<div id="licence">
							<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
								<img alt="Creative Commons Lizenzvertrag"  src="img/by-nc-sa-4.0-80x15.png" /></a>
								<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Teile und Herrsche</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="http://twitter.com/bentolor" property="cc:attributionName" rel="cc:attributionURL">Benjamin Schmid, Dr. Ralph Guderlei</a> ist lizenziert unter einer <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons-Lizenz (by-nc-sa)</a>. Beruht <a xmlns:dct="http://purl.org/dc/terms/" href="http://lab.hakim.se/reveal-js/" rel="dct:source">Reveal.JS</a>.
						</div>
					</div>

					<aside class="notes" data-markdown>
						Thank you krita for introduction! 
						
						Glad to be here and today I'd love to ... _in 
						very shoort time_ ... give you a few inspirations
						and ideas on what to look out when "Building, Running & Maintaining Containers"

						I'll using Docker as a simple base technology for illustration, but most of the topics
						of course also apply to container runtime areas like **Kubernetes**
					</aside>


				</section>






				<section>
					<section>
						<h2 class="toc-element">Containers &dash; but why?</h2>

						<div class="container">
							<ul class="fragment fade-out" data-fragment-index="6">
								<li>
									<strong  class="fragment highlight-current-green" data-fragment-index="1">
										Isolated process execution</strong>
										via Sandboxes <br/>based on »Linux Containers (LXC)«</li>
								<li>
									Far <strong class="fragment highlight-current-green"  data-fragment-index="2">more efficient</strong> 
									compared to VMs/Hypervisors</li>
								<li>
									<strong  class="fragment highlight-current-green" data-fragment-index="3">
										Portable Format</strong> for Applications incl.
										<strong class="fragment highlight-current-green" data-fragment-index="3">Versioning
										</strong></li>
								<li>
									<strong  class="fragment highlight-current-green" data-fragment-index="4">Lightweight</strong> Runtime- &amp; Packaging tooling </li>
								<li>
									Open <strong class="fragment highlight-current-green" data-fragment-index="5">cloud repository</strong> ecosystem for base images</li>
							</ul>
						</div>

						<div data-markdown class="fragment"  data-fragment-index="6"
						     style="position: fixed;top: 38%;
						  left: 160px;
						  width: 920px;
						  height: 90px;
						  z-index: 10;
						  padding: 0 32px;
						  background-color: #f8485e;">
							**Build** Once, **Configure** Once and **Run Anywhere**
						</div>

						<aside class="notes" data-markdown>
							But first topic, I'll try to give a few insights about the benefits 
							of containers and recap a few basics on how they work.

							Well, Containers offer a set of benefits...

							So they **DO** deliver, what centuries Java promised as ....
						</aside>


					</section>

					<section>
						<!--<h3>Container vs VirtuIsolation</h3>-->

						<img alt="Container" class="plain" style="height: 600px"
							data-src="img/container_vs_virtualization_1.png"
							/><img alt="Container vs. Virtualization" class="plain fragment"  style="height: 600px"
							data-src="img/container_vs_virtualization_2.png"/>

						<aside class="notes" data-markdown>
							**How is it working?**

							* Containers are just isolated processes sharing the same machine. 
							* Linux kernel technologies like "LXC, CGroups and Namespaces" allow to cheaply 
							  define process sandboxes and limit what parts of the host hey can see.
							* Containers **share the same OS Kernel, Hardware and RAM of the host!**
							* They have an isolated, self-contained file system of all user space
							  applications like the runtime libraries & application
							* Also have their own network devices
							* All done using the sandboxing mechanisms; making this type of "Virtualization" 
							incredible **cheap**
							* **In comparison VMs virtualize a full hardware stack**, which is 
							much more expensive and makes resource sharing tehnically  more difficult
						</aside>
					</section>



				</section>

				<section>
					<h2>(Some) Key Objectives</h2>
					<h4 style="margin: -35px 0 50px 0;">for container image maintenance</h4>

					<div data-markdown>
						1. Performance & **Size**

						1. Security & **Update Management**

						1. **Diagnostics** & Resiliency
						
						1. System **Hardening**

						1. Safe & **Secure Runtime Environments**

					</div>
					<aside class="notes" data-markdown>
						So for today I'll talk about a few hand-picked Key Objectives 
						and Best Practices in the domain of Managing Containers, namely...
					</aside>
				</section>

				
				<section>
					<section data-background-video="video/pexels-polina-kovaleva-5645055.mp4" data-background-video-loop="true">
						<div class="pc90 container" data-markdown>
							# Container Diet
						</div>
						<aside class="notes" data-markdown>
							Let's start with the first one: Image Size:

							Because Containers are mostly **running in distributed systems**
							and **constantly getting created, started & stopped and thrown away**, 
							Image size is an important aspect for overall performance.

							And I thinkg we all do know well, how easy it is to gain weight...
						</aside>						
					</section>

					<section>
						<h3>Building Images using: <code>Dockerfile</code></h3>

						<pre><code data-trim class="docker compact">FROM openjdk:slim
MAINTAINER Inspector Gadget

                            # Run a command within container
RUN apt-get update &amp;&amp; apt-get install unzip -y &amp;&amp;  \
    apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

                            # include JAR and Config file
WORKDIR /opt
ADD target/rest-microservice-1.0.0.jar app.jar
ADD src/main/resources/example.yml     app.yml

                            # announce exported port 8080 and 8081
EXPOSE 8080 8081
                            # Important: separates volumes for data
VOLUME ["/srv/"]
                            # Run JAR on container startup
ENTRYPOINT java -jar app.jar server
							</code></pre>

						<aside class="notes sm" data-markdown>
							Together we'll try to destruct & understand how Container images 
							are built, so that we can better understand, how we can keep them slim!

							Here a typical example for assembling an image usind a `Dockerfile`. 

							- Starting from a base Base-Image
							- Using `RUN` do do things inside the container
							- Adding files into the containeer via `ADD`. 
							- Provide some Meta information like `EXPOSE`d Port und `ENTRYPOINT` process 
							- And we'll about `VOLUME` later again
						</aside>
					</section>

					<section>
						<!-- <h3>Layers &amp; Union File System</h3> -->
						<img data-src="img/layers.png" alt="Docker Layers" class="plain"
						/>

						<aside class="notes" data-markdown>
							What's happening behind the scenes? 
							- A container *filesystem* consists of several, stacked *Layers*
							- The union filesystem provides a, well, unified view on those layers
							- **Images** are just a set of *write-protected* layers while..
							- containers just offers an additional, writeable Layer on top 
							
							-> This makes it a **Container**. And this makes them so cheap, bc you simply can 
							disard the topmost layer to start of fresh

							**The important part**
							- Each Dockerfile steps adds a new, immutable layer -> `docker history`
							   -  Everything in there, wil stay forever & add to the size
							- Layer-ID == Container/Image ID, similar to the Git versioning using Git hashes: `ac408c338`
						</aside>
					</section>

					<section>
						<h2>Layers &amp; Union File System</h2>

						<div data-markdown>
							- Filesystem consiting of stacked **layers** (Union File System)
							- **Images** are write-protected Layers &amp; Metadata
							- Writeable layer ontop ➱ **Container**.
							- Dockerfile: Each steps creates a new layer ➱ `docker history`
							- **Versioning:** Layer-ID = Container/Image ID ➱ `ac408c338`
						</div>
						<aside class="notes" data-markdown>
							_Recap; skip_
						</aside>
					</section>


					<section>
						<video controls data-autoplay src="img/docker-layers.mp4"></video>
						Reduce layer count &amp; sizes by joining build steps
						<aside class="notes" data-markdown>
							Let's see a demo!

							1. First step: We'll use our example Dockerfuile and build the container image
							2. Next: Let's use `docker history` to understand the image step. **See the 18Meg?**
							3. Another valueable CLI tool: `dive`. Explore the contents & sizes of a image interactively.
							4. Now: I modified my Dockerfile to **do file update & deletion in one step**
							5. Running again you can see: 18M -> 0.5M
						</aside>
					</section>

					<section>
						<div data-markdown="">
							### More ways to loose weight…
							* Smaller Base Images, i.e. **Google Project "Distroless"**   <!-- -->
							    * `openjdk:slim` → 426 MB    <!-- -->
							    * `gcr.io/distroless/java:11` → 228MB
							* **Special tools** like `docker-slim`, `jlink`, …
							* **Multistage Builds** for _Build_-Container vs. _Run_-Container
							* **Merge layers** using `docker build --squash …`
						</div>

						<aside class="notes" data-markdown>
							Besides reducing the steps & layer size, a few more options to ...
						</aside>

					</section>

				</section>


				<section>
					<section data-background-video="video/Pexels_Videos_2070044.mp4" data-background-video-muted="true" >
						<div class="pc90 container" data-markdown>
							# Secure & Fresh
						</div>
						<aside class="notes" data-markdown>
							Next topic: Update & Security management!
						</aside>
					</section data-markdown>

					<section >
						<div class="pc90 container" data-markdown>
							## New Challenges in DevOps

							DevOps engineers inherit responsibility & maintenance duties 
							for **all** parts of a system → **dedicated management required**

						</div>
						<div class="fragment container" data-markdown>
							###### Continuously

							* (Security) **Updates** & Releases
							* **Dependency Scanning**   <!-- -->
							  _i.e., using `renovatebot` or `Gemnasium`_
							* **Container Scanning**, i.e. using `trivy` or `grype`  <!-- -->
							* **Infrastructure Scanning**, i.e. `kics`    <!-- -->
							→ _Terraform, K8s, Docker, CloudFormation, CDK, Helm_
						</div>
						<aside class="notes" data-markdown>
							... you inherited a whole bunch of routine jobs, formerly done by the ops team!

							Therefore you need to to **continuously**

							* Care for ýour application dependencies & bundled services
							* Care for what inside your runtime environment, i.e., OS level
							* Care for your security of the Cloud-native ifnrastructure
						</aside>
					</section>


					<section >
						<div class="" data-markdown>
							# Choose carefully! 
							## → Less is More!
						</div>
						<aside class="notes" data-markdown>
							... to limit your management work, to to limit your dependencies to a minimum!
						</aside>
					</section>


					<section>
						<div class="" data-markdown>
							## `trivy`

							```bash
							$ docker run --rm \
							      -v /var/run/docker.sock:/var/run/docker.sock \
								  -v /tmp/triycache/:/root/.cache/ aquasec/trivy \
								  image my/microservice
							```

							## `grype`

							```bash
							$ grype docker:my/microservice 
							```
						</div>
						<aside class="notes" data-markdown>
							I'll show one tool to do Container Scanning: Trivy; here's the command I'm using 
							to start a local scan of my image _my/microservice_...
						</aside>
					</section>

					<section>
						<video controls data-autoplay src="img/trivy.mp4"></video>
						<aside class="notes" data-markdown>
							Here you see the output of that tool listing : 
							* open CVEs of the base image **but**
							* also detecting an open CVE ina na embedded JAR file.

							So just a little helper tool to assist you in keeping your container fresh & secure.
						</aside>
					</section>
				</section>


				<section>
					<section  data-background-video="video/pexels-cottonbro-7319202.mp4" 
							data-background-video-muted="true" data-background-video-loop="true" >
						<div class="pc90 container" data-markdown>
							# Diagnostics &amp; Resilency
						</div>
						<aside class="notes" data-markdown>
							Let's talk about **a very important topic**: Diagnostics, which is also a key to resilency.

							...and becomes crucical, when things don't work as expected
						</aside>
					</section data-markdown>

					<section >
						<div class="container" data-markdown>
							## Logging & Configuration
							* Per default write logs _unbuffered_ to `STDOUT` and `STDERR` only
							* Balance between Plain text vs. JSON log records
							* Do configuration *only* via:  <!-- -->
							_environment variables_, _secrets & config maps_
							```shell
							$ docker run --env VAR1=val1 --env VAR2=val2  …
							$ docker run --env-file env.list  …
							```
							Fallback: Volume-mounted files

						</div>
						<aside class="notes" data-markdown>
							A few best practices here:

							1. Log unbuffed to stdout
							1. Prepare for log ingestion/collection
						</aside>
					</section>

					<section >
						<div class="container" data-markdown>
							## Data Management
							* **Do not** store _any_ data inside containers  <!-- -->
							  → containers are disposables & stateless
							* **Do** data storage exclusively via volumes & services
							* _Ideally:_ filesystem of containers are _r/o_:
							```
							docker run … --read-only
							               --tmpfs /run:rw  myservice
							```
						</div>
					</section>

					<section >
						<div class="container " data-markdown>
							## Health Checks

							**Do** offer monitoring endpoints, like health check (`/health`), <!-- --> 
							readiness (`/ready`) and optionally metrics (`/metrics`).

							Usage declaration, i.e. in a `Dockerfile`:
```Docker
HEALTHCHECK --interval=60s --timeout=3s \    <!-- -->
            --start-period=5s --retries=3 \   <!-- -->
	CMD curl -f http://localhost:8080/v1/health || exit 1
```
						</div>
					</section>

				</section>


				<section>
					<section   data-background-video="video/pexels-mikhail-nilov-6963744.mp4" 
						data-background-video-muted="true" data-background-video-loop="true">
						<div class="pc90 container" data-markdown>
							# Tame the Attackers!
						</div>
						<aside class="notes" data-markdown>
							Let's talk about security hardening. 
							
							This important, because containers have a sub-optimal default property...
						</aside>
					</section >

					<section >
						<div class="container pc90" data-markdown>
							## Does it always need to be `root`?
							
							* Docker-Daemon: Owns _total_ control over the host 
							* Containers: Per default sharing many privileges
							
							To limit the Impact of a RCE, run applications inside 
							container via `USER` as _non-privileged, non `sudo`-able_:

							```
							FROM alpine
							# Create user and set ownership and permissions as required
							RUN adduser -D myuser && chown -R myuser /myapp
							USER myuser
							ENTRYPOINT ["/myapp/app"]
							```
						</div>
					</section>

					<section >
						<div class="container pc90" data-markdown>
							## Keep your eyes open on choosing base images!
							* Marked as _verified_ &amp; _official_?
							* Actively supported & receiving regular security updates?
							* Suspicious? Check the `Dockerfile` of the source!	
							* Names & tags are smoke and mirrors!  <!-- -->
							  → Trusted sources or use SHA1 for refering   <!-- -->
							  → `latest` can be a pitfall
						</div>
					</section>

 					<section >
						<div class="pc90 container" data-markdown>
							## PID 1, Signals & Zombies
							* If child processes are dying inside containers,  <!-- -->
							they need to be _'reaped'_ → `init` process
							   * `docker run --init …`
							   * Use only one process as `ENTRYPOINT`
							   * Use an init system like _tini_
							* This process should also handle Signals like `TERM`, `HUP`!
							* Goal: One process per container
						</div>
					</section>



					<section >
						<div class="pc90 container" data-markdown>
							## More best practices
							* Lint your `Dockerfile` i.e., using [Hadolint](https://hadolint.github.io/hadolint/)
							* Use `.dockerignore`; prefer `COPY` over `ADD`
							* Understand, use & control the Docker build cache
							* **Immutable** is key
							* Always _fully_ **externalize configuration**
						</div>
					</section>



					<section data-background="img/spark.jpg" data-background-transition="zoom">
						<div class="container"
							style="background-color: rgba(64,64,64,.8); border: 2px solid #555;
						 	position: absolute; left: 0px; padding: 0 32px 18px; "
							data-markdown>
							**Microservice Frameworks**
							- **Quarkus.io**
							- **Micronaut.io**
							- **Helidon**
							- Spring Fu 
							- Ktor
							- Spark Framework
							- Dropwizard
							- Spring Boot
							- Vert.x
						</div>

						<aside class="notes" data-markdown>

							- Spring Fu 
							- Ktor
							- Spark: Micro-Framework
							- Dropwizard: Best of JEE
							- Spring Boot: Stand-alone Apps
							- Vert.X: Reactive Apps
						</aside>
					</section>

					<section data-background="img/pom-maven.jpg" data-background-transition="zoom">
						<div class="container decent"
							style="background-color: rgba(64,64,78,.8); width: 480px; border: 2px solid #666;
						 	position: absolute; right: 0px; top: 0px; padding: 0 32px 18px;"
							data-markdown>
							#### Build alternatives
							
							* Paketo.io
							* jib 
							* s2i (source-to-image)
							* &hellip;
						</div>
						<div style="width: 100%; height: 600px;"/>

						<aside class="notes" data-markdown>
							- Maven: 4 plugins
							- CI-Server: Kommt eigentlich überall
						    - IDE Integration: Eclipse "Docker Explorer" nur angekündigt
						</aside>
					</section>




				</section>




				<section>
					<section data-background-video="video/fenton.webm" >
						<div class="pc90 container" data-markdown >
							# Fenton! Feeeenton!!
							### «Where are they running?»
						</div>
					</section>

					<section >
						<div class="container" data-markdown>
							## Docker Daemon & `docker.sock`
							Access to `docker.socket` effectively is root access on host!

							* Preferably limit access  _only_ to `127.0.0.1` and _only_ for `root`
							* If it has to be: Securely protect TCP access!
							* Consider _podman_ as rootless runtime alternative
						</div>
					</section>

					<section >
						<div class="container pc90" data-markdown>
							## Privileges & Limits
							
							By default container own _extensive_ host privileges & _capabilities_!
							Adding `--privileged` equals completely surrendering sandboxing at all.

							→ Therefore, **do** run container always with as **minimal capabilities** 
							and **resource limits** as possible:

							```bash
							$ docker run --cap-drop all --cap-add … \
							             --security-opt="no-new-privileges" \
										 --memory="1g" --memory-swap="1g" \ 
										 --cpus="2.5" --cpu-shares="2048"
							```
						</div>
					</section>

					<section >
						<div class="container" data-markdown>
							## Get hints by `docker-bench`
							On the fly, use tools such as `docker-bench-security`, 
							which offer recommendations for hardening via heuristics:

							```bash
							$ sudo docker run --rm --net host --pid host \
										--userns host --cap-add audit_control \
										-v /etc:/etc:ro \
										-v /lib/systemd/system:/lib/systemd/system:ro \
										-v /usr/bin/containerd:/usr/bin/containerd:ro \
										-v /usr/bin/runc:/usr/bin/runc:ro \
										-v /usr/lib/systemd:/usr/lib/systemd:ro \
										-v /var/lib:/var/lib:ro \
										-v /var/run/docker.sock:/var/run/docker.sock:ro \
										--label docker_bench_security \
										docker/docker-bench-security
							```
						</div>
					</section>

					<section>
						<video controls data-autoplay src="img/docker-bench.mp4"></video>
					</section>
				</section>

				<section data-background-video="video/pexels-rodnae-productions-7563906.mp4" 
						 data-background-video-loop="true"
						 data-undim
				>
<!-- 					<div class="pc90 container" data-markdown>
						# Thank you!
					</div>
 -->				
				</section>


<!-- 				<section>
						<h2>Docker Kommandos</h2>

						<div data-markdown style="font-size: 0.6em; float: left; margin-top: -32px;">
							##### Images managen

							| Kommando        | Beschreibung                               |
							|-----------------|--------------------------------------------|
							| `docker images` | Liste der lokal vorhandenen Images         |
							| `docker pull`   | Image-Download aus dem Repository          |
							| `docker build`  | Docker Image via `Dockerfile` erstellen    |
							| `docker commit` | Containers als neues Image comitten        |

							##### Container kontrollieren

							| Kommando        | Beschreibung                               |
							|-----------------|--------------------------------------------|
							| `docker run`    | Erzeugen eines neuen Containers            |
							| `docker start`  | Starten eines bestehenden Containers       |
							| `docker stop`   | Stoppen eines Containers                   |
							| `docker ps -a`  | Liste _aller_ Container                    |
							| `docker kill`   | Stoppen mit Nachdruck                      |
						</div>

						<div data-markdown style="font-size: 0.6em;  width:48%; float: right; margin-top: -32px;">
							##### Diagnose &amp; Tools

							| Kommando          | Beschreibung                                             |
							|-------------------|----------------------------------------------------------|
							| `docker inspect`  | Low-Level Informationen über Container/Images            |
							| `docker log`      | Terminal-Ausgaben des Containers                         |
							| `docker exec`     | Prozess im Container starten, z.B. interaktive Shell     |
							| **`docker diff`** | Was wurde im Container geändert?                         |
							| `docker history`  | Image: Welche Schichten &amp; wie entstanden?            |
						</div>

						<aside class="notes" data-markdown>
							Zum Abschluß noch ein kurzer Überblick über die wichtigsten Komandos als Eindruck.
							Die meisten der Kommandos haben wir kennen gelernt und gehen daher die Liste nicht
							noch einmal durch.

							Erwähnenswert ist z.B. noch `docker diff`. Eines der leistungsfähigen Aspekte von Docker.
						</aside>
					</section>-->





			</div>
		</div>


		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				hash: true, 

				// Display controls in the bottom right corner
			    controls: false,

			    // Display a presentation progress bar
			    progress: true,

			    // Display the page number of the current slide
			    slideNumber: true,

			    // Push each slide change to the browser history
			    history: true,

			    // Enable keyboard shortcuts for navigation
			    keyboard: true,

			    // Enable the slide overview mode
			    overview: true,

			    // Vertical centering of slides
			    center: true,

			    // Enables touch navigation on devices with touch input
			    touch: true,

			    // Loop the presentation
			    loop: false,

			    // Change the presentation direction to be RTL
			    rtl: false,

			    // Turns fragments on and off globally
			    fragments: true,

			    // Flags if the presentation is running in an embedded mode,
			    // i.e. contained within a limited portion of the screen
			    embedded: false,

			    // Flags if we should show a help overlay when the questionmark
			    // key is pressed
			    help: true,

			    // Number of milliseconds between automatically proceeding to the
			    // next slide, disabled when set to 0, this value can be overwritten
			    // by using a data-autoslide attribute on your slides
			    autoSlide: 000,

			    // Stop auto-sliding after user input
			    autoSlideStoppable: true,

			    // Enable slide navigation via mouse wheel
			    mouseWheel: true,

			    // Hides the address bar on mobile devices
			    hideAddressBar: true,

			    // Opens links in an iframe preview overlay
			    previewLinks: true,

			    // Transition style
			    transition: 'slide', // none/fade/slide/convex/concave/zoom

			    // Transition speed
			    transitionSpeed: 'default', // default/fast/slow

			    // Transition style for full page slide backgrounds
			    backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

			    // Number of slides away from the current that are visible
			    viewDistance: 3,

			    // Parallax background image
			    parallaxBackgroundImage: 'img/nagarro-bg.jpg', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

			    // Parallax background size
			    parallaxBackgroundSize: '4096px 2073px', // CSS syntax, e.g. "2100px 900px"

			    // Amount to move parallax background (horizontal and vertical) on slide change
			    // Number, e.g. 100
			    parallaxBackgroundHorizontal: '',
			    parallaxBackgroundVertical: '',

				// The "normal" size of the presentation, aspect ratio will be preserved
			    // when the presentation is scaled to fit different resolutions. Can be
			    // specified using percentage units.
			    width: 1280,
			    height: 720,

			    // Factor of the display size that should remain empty around the content
			    margin: 0.05,

			    // Bounds for smallest/largest possible scale to apply to content
			    minScale: 0.2,
			    maxScale: 1.5,

				// Ctrl + Mouse-Click ==> Zoom in
				zoomKey: 'ctrl',


				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]

				// Optional reveal.js plugins
				/*dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]*/
			});

			Reveal.addEventListener( 'webm-video', function() {
				var videoElems = document.getElementsByTagName("VIDEO");
    			if (videoElems && videoElems.length > 0) {
					videoElems[0].playbackRate = 3.0;
				}
			} );

			Reveal.on('slidechanged', e => {
				if (e && e.currentSlide) {
					let isRemoveDim = e.currentSlide.hasAttribute("data-undim");
					let bg = document.getElementsByClassName("backgrounds")[0];
					if (isRemoveDim) bg.style.filter = 'none'
					else bg.style.filter = '';
				}
			});

		</script>
	</body>
</html>
