<!doctype html>
<html lang="de">

	<head>
		<meta charset="utf-8">

		<title>Teile und Herrsche - Verteilte Java-Anwendungen mit Docker</title>

		<meta name="description" content="Eine Einführung in den Einsatz von docker für Java-Anwendungen">
		<meta name="author" content="Benjamin Schmid, Dr. Ralph Guderlei">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Custom, overriding CSS -->
		<link rel="stylesheet" href="css/docker.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<!--
				<section data-markdown>
					TODO
					----
					- Trademark Hinweise bei den Logofolien aufnehmen
					- Screen-Recordings der Live-Demos
					- Live-Demos Seiten als Fragements mit Live-Recordings zu einer Seite zusammenfassen
				</section>
-->
				<section>
					<div id="title">
					<h1 style="margin: 10px">Teile und Herrsche</h1>
					<h3>Verteilte Java-Anwendungen mit Docker</h3>

					<!-- Profil-Karten -->
					<div class="container">
					    <div class="profile">
								<div class="profile-sidebar">
									<div class="profile-userpic">
										<img data-src="img/BenjaminSchmid.jpg" class="img-responsive" alt="">
									</div>
									<div class="profile-usertitle">
										<div class="profile-usertitle-name">
											Benjamin Schmid
										</div>
										<div class="profile-usertitle-job">
											Technology Advisor
										</div>
									</div>
							</div>
							<div class="profile-content">
				   				<a href="https://twitter.com/bentolor">@bentolor</a>
	            			</div>
						</div>
					    <div class="profile">
								<div class="profile-sidebar">
									<div class="profile-userpic">
										<img data-src="img/rguderlei.png" class="img-responsive" alt="">
									</div>
									<div class="profile-usertitle">
										<div class="profile-usertitle-name">
											Dr. Ralph Guderlei
										</div>
										<div class="profile-usertitle-job">
											Technology Advisor
										</div>
									</div>
							</div>
							<div class="profile-content">
				   				<a href="https://twitter.com/rguderlei">@rguderlei</a>
	            			</div>
						</div>
					</div>
					</div>

					<div id="footer">
						<div id="logo">
							<img src="img/eXXcellent logo-transparent.png" alt="eXXcellent solutions" />
						</div>
						<div id="helpfooter">
							? für Hilfe, S für Folien-Notizen
						</div>
						<div id="version">
							15. Juni 2015
						</div>
						<div id="licence">
							<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
								<img alt="Creative Commons Lizenzvertrag"  src="img/by-nc-sa-4.0-80x15.png" /></a>
								<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Teile und Herrsche</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="http://twitter.com/bentolor" property="cc:attributionName" rel="cc:attributionURL">Benjamin Schmid, Dr. Ralph Guderlei</a> ist lizenziert unter einer <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons-Lizenz (by-nc-sa)</a>. Beruht <a xmlns:dct="http://purl.org/dc/terms/" href="http://lab.hakim.se/reveal-js/" rel="dct:source">Reveal.JS</a>.
						</div>
					</div>
				</section>

				<section  data-transition="zoom">
					<img class="plain" data-src="img/docker-logo-large-dark-horiz-transparent.png" alt="Docker logo" />

					<aside class="notes">
						Überall hört und liest man von "docker".
					</aside>
				</section>

				<section data-transition="zoom">

					<section data-background="https://33.media.tumblr.com/653f26dc9e1a4d9aa9fffacf9d119f00/tumblr_mqycfbnyGH1s7r5iqo1_500.gif"  data-transition="zoom">
						<!-- via http://youngmunchkin.tumblr.com/post/57238759142 -->
						<h1>150 Mio. USD Risikokapital</h1>

						<aside class="notes" data-markdown>
							Insgesamt **150 Mio. USD Risikokapital** konnte das Unternehmen an rund um die Open-Source
							Systemvirtualisierung einnehmen.
						</aside>
					</section>

					<section data-transition="zoom">
						<div class="fragment grow" style="position: absolute; top: 200px; left: 100px;">
							<img alt="Red Hat Logo" class="glow plain" style="width:400px;" data-src="https://upload.wikimedia.org/wikipedia/ar/6/6c/RedHat.svg"/></div>
						<div class="fragment grow"  style="margin-top: -0px;">
							<img alt="Google Logo" class="glow plain" style="width:400px;" data-src="https://upload.wikimedia.org/wikipedia/commons/a/aa/Logo_Google_2013_Official.svg"/></div>
						<div class="fragment grow"  style="position: absolute; top: 250px; right: 100px;">
							<img alt="Amazon Logo" class="glow plain" style="width:400px;" data-src="https://upload.wikimedia.org/wikipedia/commons/6/62/Amazon.com-Logo.svg"/>
						</div>
						<div class="fragment grow"  style="margin-top: 250px; ">
							<img alt="Microsoft Logo" class="glow plain" style="width:400px;" data-src="https://upload.wikimedia.org/wikipedia/commons/9/96/Microsoft_logo_(2012).svg"/>
						</div>

						<div style="font-size: 0.4em;  margin: 20px auto; color: #666;">
							Alle Warenzeichen und Logos sind Eigentum ihrer jeweiligen Rechteinhaber.
						</div>

						<aside class="notes" data-markdown>
							Zu seinen Unterstützern gehört eine ganze Riege namhafter Unternehmen, wie z.B.:

							Red Hat, Google, Amazon

							um ein paar zu nennen.

							Selbst **Microsoft arbeitet inzwischen** mit Docker zusammen,, um die eigentlich auf Linux
							beheimatete Technologie auch auf Windows &amp; Azure zu portieren!</aside>
					</section>

					<section>
						<h2 class="fragment grow highlight-current-blue">Hype?</h2>
						<p style="text-align: center; color: #aaa; font-style: italic">oder</h2>
						<h2 class="fragment grow highlight-current-blue">»The next big thing«?</h2>
						<div class="fragment"/>

						<aside class="notes" data-markdown>
							Ist das Docker nur ein Hype oder wirklich »the next big thing«? Dieser Frage möchten
							wir heute auf den Grund gehen!

							<br> Hallo und Ein herzliches Willkommen zu unsere_ — mein Name ist '...'.
							Speaker 2:  Mein Name ist Ralph Guderlei ... und gemeinsam wollen wir heute ein bisschen
							Licht auf das Schlagwort Docker werfen.
						</aside>
					</section>

					<section>
						<h2>Jump into Docker: Live Demo</h2>
						<div class="fragment compact" style="width: 1000px; margin: auto">
						<pre><code data-trim class="bash" >
$ mvn -o package
$ java -jar target/rest-microservice-1.0.0.jar server
$ sensible-browser "http://localhost:8080/hello-world"
</code></pre>
						<pre><code data-trim class="bash">
$ docker build -t my/microservice .

$ docker run -d --name web1 my/microservice
$ docker run -d --name web2 my/microservice
$ docker run -d --name web3 my/microservice

$ docker pull haproxy:1.5
$ docker run -d --name balancer \
	--link web1:web1 --link web2:web2 --link web3:web3 \
	-p 8080:80 \
	-v (pwd)/etc:/usr/local/etc/haproxy:ro \
	haproxy:1.5
$ sensible-browser "http://localhost:8080/hello-world"
						</code></pre>
						</div>

						<aside class="notes sm" data-markdown>
							Um die Faszination hinter Dockjer etwas plastischer zu gestalten, fangen wir am Besten
							doch einfach gleich mal mit einem kleinen Beispiel an.

							Starten wir doch mit einem Java-basierten Service.

							Wir haben da schon mal was vorbereitet, das bauen wir mal.
							Unser Beispiel ist ein kleiner Microservice auf Basis von Dropwizard.

							Zugegebenermassen: So richtig viel macht unser Service nicht. Trotzdem kann ja mal was schief
							gehen! Darum wollen wir mal zeigen, wie leicht wir mit Docker daraus ein High Availability Cluster
							bauen können!

							Im ersten schritt "Dockerizen" wir dazu unsere Anwendung. Wie das genau geht, schauen wir
							uns später noch im Detail an.

							Wir haben unsere Java-Anwendung nun als Docker-Container verpackt. Da wir Ausfallsicherheit
							haben wollen, starten wir einfach mal drei Instanzen davon.
							**Dabei müssen wir nichts umkonfigurieren, da diese drei Instanzen in isolierten Container
							laufen!**

							Um nun die Ausfallsicherheit zu realisieren, greifen wir auf einen fertigen Container
							für den Loadbalancer HAProxy zurück. Beim Start machen wir dieser nur noch
							unsere Konfiguriationsdatei und die drei gestarteten Container bekannt!

							Und schon haben wir unseren geclusterten "Hochverfügbarkeits"-Cluster deployed!
						</aside>
					</section>

					<section data-background="https://media.giphy.com/media/itDBteCsTFSVO/giphy.gif">
						<aside class="notes" data-markdown>
							Und schon haben wir unseren geclusterten "Hochverfügbarkeits"-Cluster deployed!

							- Wir mussten nichts zusätzlich installieren
							- Schnell gestartet
							- Ohne unser Anwendung anpassen zu müssen
							- Portabel: Könnte so genaus auf Produktion gehen!
						</aside>
					</section>

				</section>

				<!--
				#######################################################################################################
					Docker in a nutshell
				#######################################################################################################
				-->

				<section>

					<section>
						<h3>Inhaltsverzeichnis</h3>

					    <div id="table-of-contents"></div>
					</section>

					<section>
						<h2 class="toc-element">Docker in a nutshell</h2>

						<div class="container">
							<ul class="fragment fade-out" data-fragment-index="6">
								<li>
									<strong class="fragment highlight-blue" data-fragment-index="1">
										Isolierte Prozessausführung</strong> (Sandbox)
										<br> auf Basis von »Linux Containers (LXC)«</li>
								<li>
									Wesentlich <strong class="fragment highlight-blue" data-fragment-index="2">
										effizienter</strong> als VMs/Hypervisoren</li>
								<li>
									<strong  class="fragment highlight-blue" data-fragment-index="3">
										Portables Format</strong> für Container mit
										<strong class="fragment highlight-blue" data-fragment-index="3">Versionierung
										</strong></li>
								<li>
									<strong  class="fragment highlight-blue" data-fragment-index="4">
										Leichtgewichtige</strong> Laufzeit- und Packaging-Tools </li>
								<li>
									<strong  class="fragment highlight-blue" data-fragment-index="5">
										Cloud-Repository</strong> für Container-Vorlagen </li>
							</ul>
						</div>

						<div data-markdown class="fragment container"  data-fragment-index="6"
						     style="position: fixed;top: 40%;
						  left: 200px;
						  width: 800px;
						  height: 90px;
						  z-index: 10;
						  padding: 0 40px;
						  background-color: rgba(66, 175, 250, 1);">
							**Build** Once, **Configure** Once and **Run Anywhere**
						</div>
					</section>

					<section>
						<h3>Grundlegende Begriffe</h3>

						<div>
							<img data-src="img/icon-layers.png" alt="Image and Layers" class="floaticon plain" />
							<p class="floaticon">
								<strong>Image:</strong> Paketierte Zusammenstellung von Dateien.
								Damit eine <em>schreibgeschützte Blaupause</em> für eine Systemumgebung.
							</p>
							<div class="fragment">
								<img data-src="img/icon-container.png" alt="Container" class="floaticon plain" />
								<p class="floaticon">
									<strong>Container:</strong> Eine unabhängige Systemumgebung
									basierend auf einem Image
								</p>
							</div>

							<div class="fragment">
								<img data-src="img/icon-repo.png" alt="Repository" class="floaticon plain" />
								<p class="floaticon">
									<strong>Repository:</strong> Ein Sammlung von Images auf dem lokalen Docker oder
									zentralen Registry Server
								</p>
							</div>
						</div>

						<aside class="notes" data-markdown>
						</aside>
					</section>

					<section>
						<h3>Docker Komponenten</h3>

						<div>
							<img class="plain" data-src="img/docker-components.png" style="height: 600px;"/>

						</div>

						<aside class="notes" data-markdown>
							- Auf der Host-Machine läuft ein Daemon.
							  - Dieser verwaltet sowohl die laufenden Container, als auch die Images.
							  - Der Daemon ist also Zuständig dafür, Container-Instanzen anzulegen, starten und zu
								stoppen
							- Über ein CLI Tool kann der Docker Dienst (remote) gesteuert werden.
							- Aus dem Cloud-Repository lassen sich Images abholen
						</aside>
					</section>

					<section>
						<!--<h3>Container vs VirtuIsolation</h3>-->

						<img alt="Container" class="plain" style="height: 600px"
							data-src="img/container_vs_virtualization_1.png"
							/><img alt="Container vs. Virtualization" class="plain fragment"  style="height: 600px"
							data-src="img/container_vs_virtualization_2.png"/>

						<aside class="notes" data-markdown>
							- Container laufen dank **LXC & Namespaces** als voneinander **vollständig isolierte, aber
							  sonst ganz normale Prozesse** auf dem Host-System.
							- Es handelt sich um keine vollständige Virtualisierung
							    - Kernel und RAM wird mit dem Host geteilt
							    - Nur die im Image gebundelten Dateien & Tools sind zugänglich
							      (auch Dinge wie `ls`)
							    - Isoliertes Container-Netzwerk
							    - Container sieht nur eigene Prozesse
							- Durch diesen Ansatz ist alles **cheap**: Anlegen, Verwerfen, Starten, Stoppen
						</aside>
					</section>

					<section>
						<h3>Erstellen von Images </h3>

						<div class="container" style="max-width: 80%;">
							<p>

							</p>
							<p data-markdown >
								1. **Manuell:** *Commit* eines Containers
								2. **Automatisiert:** via `Dockerfile`
							</p>
							<p data-markdown  class="decent tgap">
								In der Regel: Automatisiert, aufbauend auf     <!--  -->
								einem via `docker pull` bezogenem Base-Image
							</p>
						</div>

						<aside class="notes" data-markdown>
							- Images lassen sich auf zwei Arten erstellen:
							   - Commit eines Containers
							   - Generiert via Dockerfile
							- in der Regel aber: Automatisierte Erstellung anhand des «Build-Files»: `Dockerfile`
						</aside>
					</section>

					<section data-background="img/docker-lib-extract.png">

						<div id="baseimages">
							<h4 style="color: #333;">Base Images</h4>

							<div data-markdown>
							- [~100 offizielle Images](https://hub.docker.com/explore/)
							- 100.000+ Images insgesamt
							- 200+ Millionen Downloads
							</div>
						</div>


						<aside class="notes" data-markdown>
							- drei Klassen:
							  - Betriebsysteme
								- Laufzeitumgebungen (Java, Ruby)
								- Anwendungen (Datenbanken, Wordpress)
							- untrusted, Signatur-Infrastruktur im Aufbau
						</aside>
					</section>

					<section>
						<h3>Images bauen: <code>Dockerfile</code></h3>

						<pre><code data-trim class="docker compact">FROM java:8
MAINTAINER Inspector Gadget

                            # Kommando im Container ausführen
RUN apt-get update &amp;&amp; apt-get dist-upgrade -y &amp;&amp;  \
    apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

                            # JAR und Config-File in Image aufnehmen
WORKDIR /opt
ADD target/rest-microservice-1.0.0.jar app.jar
ADD src/main/resources/example.yml     app.yml

                            # announce exported port 8080 and 8081
EXPOSE 8080 8081
                            # Wichtig: Separate Volumes für Daten
VOLUME ["/srv/"]

                            # JAR ausführen beim Start des Containers
ENTRYPOINT java -jar app.jar server
							</code></pre>

						<aside class="notes sm" data-markdown>
							Hier unser Eingangs präsentiertes Beispiel:

							- Zuerst mal starten wir von einem Base-Image
							- Mit `RUN` könenn wir Kommando _innerhalb_ des Containers ausführen
							- Dann fügen wir Dateien von ausserhalb in den Container hinzu: Hier unsere App-JAR
							  und Konfigurationsdatei
							- `EXPOSE` und `ENTRYPOINT` sind Meta-Informationen die Beschreiben, wie der Container
							   verwendet werden soll. Konkret: Welche Ports aus dem Container später zugänglich
							   sein sollen und Was beim Container-Start ausführen. In der Regel 1 Prozess.
							- `VOLUME`: Betrachten wir später
						</aside>
					</section>

				</section>

				<!--
				#######################################################################################################
					Hands on Docker
				#######################################################################################################
				-->

				<section>
					<h1 class="toc-element">Hands on Docker</h1>
				</section>

				<section data-transition="fade" data-background="#222">
					<div class="pc90 container" data-markdown>
						#### Neues Image erstellen

						Auf Basis unseres `Dockerfile` erzeugen wir unser Image:

						```
						docker images
						docker build -t my/dockerapp:latest .
						docker images
						```

						Dabei sehen wir wie die Schritte einzeln abgearbeitet werden; bei jedem der Schritte
						entsteht ein neuer Layer. Mehr dazu später.
					</div>

					<aside class="notes" data-markdown>
						- Welche Images sind da?
						- `Dockerfile` -> Neues Image
					</aside>
				</section data-markdown>

				<section data-transition="fade" data-background="#222">
					<div class="pc90 container" data-markdown>
						#### Container erstellen & starten

						Nun starten einen neuen (anonynmen) Container auf Basis des Images: Einmal interaktiv,
						einmal als Daemon

						```
						docker run -it my/dockerapp
						[ctrl-c]
						docker run -d my/dockerapp
						```
					</div>

					<aside class="notes" data-markdown>
						- Wir _legen_ neuen Container via `docker run` an
						- Das startet ihn auch gleich.
						- Dank `-it` interaktiv im Vordegrund
					</aside>
				</section data-markdown>

				<section data-transition="fade" data-background="#222">
					<div class="container pc90" data-markdown>
						#### Container managen
						Nun schauen wir mal was so los ist. Wir die eingangs gestarteten Container laufen noch,
						welche wir erst mal unsanft killen.

							docker ps
							docker kill balancer web1 web2 web3
							docker ps

						Regulär stoppt man Container aber höflich mit `docker stop`. Wieder starten über
						`docker start` &hellip; nicht ~~`docker run`~~ .

							docker stop name
							docker ps
							docker ps -as
							docker start name

					</div>

					<aside class="notes" data-markdown>
						- Wir schauen uns die laufenden Container an.
						- Wir stoppen wieder unseren Container:
							- `ps` zeigt ihn nicht mehr.
							- mit `ps -as` sehen wir auch die gestoppten.
							- Erneutes starten erfolgt dagegen via `docker start`.  nicht ~~`docker run`~~
							- **Achtung:** auch diese belegen Platz!
					</aside>
				</section data-markdown>

				<section data-transition="fade" data-background="#222">
					<div data-markdown class="container pc90">
						#### Diagnostik von Container
						Unsere Container laufen im Hintergrund. Wie kommen wir an Infos,
						wenn mal etwas nicht funktioniert?

							docker inspect name | grep IP
							sensible-browser "http://ip:8080/hello-world"

							docker logs name
							docker exec -it name /bin/bash
					</div>

					<aside class="notes" data-markdown>
						Unsere Container laufen. Wie bekommen wir Infos?

						1. Auf unserem Container läuft ja eine Web-Anwendung auf Port 8080, die wollen wir mal
						ausprobieren.
						2. Über `docker inspect` bekommt man jede Menge Infos.
						3. Mit `docker logs` die Ausgaben.
						4. Oder wir können mit `docker exec` einen Prozess im Kontext des Container starten

						Fazit:
						- `logs` zeigt uns die Konsolenausgaben
						-  `exec` erlaubt in den Container einzutauchen; z.B. eine bash Shell, um sich umzuschauen
					</aside>
				</section>

				<!--
				#######################################################################################################
					Docker advanced
				#######################################################################################################
				-->

				<section>

					<section>
						<h1 class="toc-element">Docker advanced</h1>
					</section>

					<section>
						<!-- <h3>Layers &amp; Union File System</h3> -->
						<img data-src="img/layers.png" alt="Docker Layers" class="plain"
						/>

						<aside class="notes" data-markdown>
							- *Filesystem*, bestehend aus gestapelten *Layern* (union filesystem)
							- **Image** sind *schreibgeschützt*
							- *Union File System* vereint die verschiedenen Image Layers uns stellt auf oberster
							Ebene einen *schreibbaren Layer* bereit. Das ist dann ein **Container**.
							- Image = Layers + Meta-Informationen, Ports, Volumes, Start-Kommando
							- Dockerfile: Jeder Schritt erzeugt ein separaten Layer -> `docker history`
							- Layer-ID == Container/Image ID
							- Versionierung vergleichbar zu Git-Hash: `ac408c338`
						</aside>
					</section>

					<section>
						<h2>Layers &amp; Union File System</h2>

						<div data-markdown>
							- Filesystem aus gestapelten **Layern** (Union File System)
							- **Images** sind schreibgeschützte Layers &amp; Meta
							- Schreibbarer Layer dazu ➱ **Container**.
							- Dockerfile: Jeder Schritt = **neuer Layer** ➱ `docker history`
							- **Versionierung:** Layer-ID = Container/Image ID ➱ `ac408c338`
						</div>
					</section>

					<section>
						<h2>Data Volumes</h2>

						<div class="container">
							<p>
								<strong>Datenhaltung</strong> unabhängig vom Container-Lebenszyklus. <br>
								<span class="decent">Überlebt:</span> Löschen &amp; Updates.
								<span class="decent">Erlaubt:</span> Sharing.
							</p>

							<div data-markdown class="fragment decent compact tgap" style="font-size: 80%">
								Option 1: _Container Volumes_

								    docker create -v /mydata --name mydata java:8 /bin/true
								    docker run -d --volumes-from mydata my/dockerapp

								Option 2: _Lokale Verzeichnisse_

								    docker run -v $(pwd)/etc:/usr/local/etc:ro haproxy:1.5
							</div>
						</div>
						<aside class="notes" data-markdown>
							Data volumes are designed to persist data, independent of the container's life cycle.

							- Zustandslose Services trivial, wie sieht es mit Datenbanken aus?
							- Umgang mit persistenten Daten: Volumes
							- Beispiel: Update einer Datenbank, Daten sollen erhalten werden

							If you have some persistent data that you want to share between containers, or want to
							use from non-persistent containers.

							Let's create a new named container with a volume to share. It reuses the `java:8` image
							so that all containers are using layers in common, saving disk space.
						</aside>
					</section>

					<section>

						<div class="container">
							<h2>Container verknüpfen</h2>

							<div data-markdown style="margin: 40px 0 0 0; width: 900px;">
							```
							docker run -d --name web1       my/dockerapp
							docker run -d --link web1:web1  haproxy
							```
							</div>

							<div data-markdown style="width: 800px;" class="container">
							_web1_ wird damit in _haproxy_ verfügbar via
							- Umgebungsvariablen: `WEB1_PORT`
							- IP &amp; Hostnamen: `/etc/hosts`
							</div>
						</div>

						<aside class="notes" data-markdown>
							Erzeugt Umgebungsvariablen wie `DB_PORT`, host-Einträge, ermöglicht Zugriffe auf
							Netzwerk-Ports.
							Typisches Szenario: Zugriff auf Datenbanken.
						</aside>
					</section>

					<section>
						<h2>Einstiegs-Demo revisited</h2>

						<pre style="width: 1000px; margin: auto"><code class="bash">docker build -t my/microservice

docker run -d --name web1 my/microservice
docker run -d --name web2 my/microservice
docker run -d --name web3 my/microservice

docker run -d --name balancer \
    --link web1:web1 --link web2:web2 --link web3:web3 \
    -p 8080:80 \
    -v (pwd)/etc:/usr/local/etc/haproxy:ro \
    haproxy:1.5</code></pre>

						<aside class="notes" data-markdown>
						    ...und damit haben wir alle Elemente aus der Eingangs-Demo kennen gelernt.
						</aside>
					</section>

					<section>
						<h2>Docker Kommandos</h2>

						<div data-markdown style="font-size: 0.6em; float: left; margin-top: -32px;">
							##### Images managen

							| Kommando        | Beschreibung                               |
							|-----------------|--------------------------------------------|
							| `docker images` | Liste der lokal vorhandenen Images         |
							| `docker pull`   | Image-Download aus dem Repository          |
							| `docker build`  | Docker Image via `Dockerfile` erstellen    |
							| `docker commit` | Containers als neues Image comitten        |

							##### Container kontrollieren

							| Kommando        | Beschreibung                               |
							|-----------------|--------------------------------------------|
							| `docker run`    | Erzeugen eines neuen Containers            |
							| `docker start`  | Starten eines bestehenden Containers       |
							| `docker stop`   | Stoppen eines Containers                   |
							| `docker ps -a`  | Liste _aller_ Container                    |
							| `docker kill`   | Stoppen mit Nachdruck                      |
						</div>

						<div data-markdown style="font-size: 0.6em;  width:48%; float: right; margin-top: -32px;">
							##### Diagnose &amp; Tools

							| Kommando          | Beschreibung                                             |
							|-------------------|----------------------------------------------------------|
							| `docker inspect`  | Low-Level Informationen über Container/Images            |
							| `docker log`      | Terminal-Ausgaben des Containers                         |
							| `docker exec`     | Prozess im Container starten, z.B. interaktive Shell     |
							| **`docker diff`** | Was wurde im Container geändert?                         |
							| `docker history`  | Image: Welche Schichten &amp; wie entstanden?            |
						</div>

						<aside class="notes" data-markdown>
							Zum Abschluß noch ein kurzer Überblick über die wichtigsten Komandos als Eindruck.
							Die meisten der Kommandos haben wir kennen gelernt und gehen daher die Liste nicht
							noch einmal durch.

							Erwähnenswert ist z.B. noch `docker diff`. Eines der leistungsfähigen Aspekte von Docker.
						</aside>
					</section>

				</section>


				<!--
				#######################################################################################################
					Docker & Java
				#######################################################################################################
				-->

				<section>

					<section class="toc-element">
						<h1>Docker &amp; Java</h1>
					</section>

					<section>
						<div class="container">

							<h3>Anwendungsfälle</h3>
							<div data-markdown>
								- **Entwicklung**:
								  - Lokale, isolierte & portable Umgebung
								  - Infrastruktur analog zu Produktion
								  - fixe Versionen für Tools & Laufzeitumgebungen
								- **CI-Server:** Tests in _isolierten_ Referenzumgebungen
								- **Betrieb**:
								  - einfaches Deployment
								  - Resourcenschonender Parallel-Betrieb vieler Instanzen
								- **Architektur**: Microservice als Uberjar statt Appserver
							</div>

						</div>

						<aside class="notes" data-markdown>
							#### Entwicklungsumgebung:

							- run multiple development environments from the same
								host that each have unique software, operating
								systems, and configurations
							- set up local development environments that are exactly like a live server
							- allow anyone to work on the same project with the exact same settings

							- Docker als Deployment-Artefakt
							- einfache Automatisierung möglich
							- daraus folgen die Anwendungsfälle ...
						</aside>
					</section>

					<section data-background="img/spark.jpg" data-background-transition="zoom">
						<div class="container"
							style="background-color: rgba(64,64,64,.8); border: 2px solid #555;
						 	position: absolute; left: 0px; top: -300px; padding: 0 32px 18px; "
							data-markdown>
							**Microservice Frameworks**
							- Spark Framework
							- Dropwizard
							- Spring Boot
							- Vert.x
						</div>

						<aside class="notes" data-markdown>
							- Spark: Micro-Framework
							- Dropwizard: Best of JEE
							- Spring Boot: Stand-alone Apps
							- Vert.X: Reactive Apps
						</aside>
					</section>

					<section data-background="img/pom-maven.jpg" data-background-transition="zoom">
						<div class="container decent"
							style="background-color: rgba(64,64,78,.8); width: 640px; border: 2px solid #666;
						 	position: absolute; right: 0px; top: 0px; padding: 0 32px 18px;"
							data-markdown>
							**Java Tool Plugins**
							- **Build:** Maven, Gradle, &hellip;
							- **CI-Server:** Jenkins, TeamCity, &hellip;
							- **IDEs:** IntelliJ, (Eclipse)
						</div>
						<div style="width: 100%; height: 600px;"/>

						<aside class="notes" data-markdown>
							- Maven: 4 plugins
							- CI-Server: Kommt eigentlich überall
						    - IDE Integration: Eclipse "Docker Explorer" nur angekündigt
						</aside>
					</section>

					<section>
						<h2>Best Practices</h2>
						<h4 style="margin: -35px 0 50px 0;">für Docker Images</h4>

						<div data-markdown>
							- **Immutable infrastructure**
							- Konfiguration extern halten
							- Kein blindes `docker pull`
							- Ein Prozess pro Image
							- `docker exec` statt ssh-Server
							- Logging nach `STDOUT`/`STDERR`
						</div>

						<aside class="notes" data-markdown>
							- Konfiguration; externe Volumes nutzen
							- Immutable: Keine Änderung nach docker build; keine Log-Files im Container, Footprint
							gering halten. Idee: Container == Wegwerfgut.
							- no, you will not use a community-contributed image without looking at what it will do
							- Versionierung ermöglicht einfaches Rollback
						</aside>
					</section>

					<!-- <section>
						<h2>Docker-freundliche Java-Anwendungen</h2>
						<ul>
							<li>Paketieren als uber jar</li>
							<li>Ausführbar mit <code>java -jar myapp.jar</code></li>
							<li>Konfiguration per Environment-Variablen</li>
							<li>Embedded server (jetty, undertow, vert.x, ...)</li>
							<li>Logging nach STDOUT/STDERR</li>
						</ul>
						<aside class="notes" data-markdown>
							- uberjar -> wenig zu kopieren
							- mit einem Kommando ohne viele Parameter ausführbar -> wenig Fehlermöglichkeiten
							- Konfig via environment -> einfache Konfiguration über Container-Runtime
							- embeddesd Server -> keine aufwändige Konfiguration des Containers
							- logging nach STDOUT -> docker logs
						</aside>
					</section> -->


				</section>

				<!--
				#######################################################################################################
					Orchestrierung / Clustering
				#######################################################################################################
				-->
				<section>
					<section class="toc-element">
						<h1>Docker Distributed</h1>
					</section>

					<section>
						<h2>Orchestrierung - Docker Compose</h2>
						<pre><code data-trim class="yml">
haproxy:
  image: haproxy:1.5
  ports:
    - 8080:80
  volumes:
    - ./etc/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg
  links:
    - web1
    - web2
    - web3

web1:
  image: exxcellent/docker_talk
						</code></pre>
					</section>

					<section style="background: rgba(0,0,0,.6)"
						data-background="img/blades.jpg"
						data-background-transition="zoom">

						<h2>Cluster-Betrieb</h2>
						<ul>
							<li>Verteilung &amp; Scheduling</li>
							<li>Service Discovery</li>
							<li>Load Balancing </li>
						</ul>
						<aside class="notes" data-markdown>
							Aus einem mach viele
							- bisher auf einen Host beschränkt
							- verteilte Anwendung -> viele Hosts

							Wenn man mehrere Rechner hat kommt man zu einer Reihe von Problemen:
							- wie verteilt man die Anwendung?
							- woher weiß man, auf welchem Rechner eine Anwendung/Service laufen?
							- wie wird die Last auf die einzelnen Instanzen verteilt?
						</aside>
					</section>

					<section>
						<div class="container" data-markdown>
							## Docker out of the box
							##### Pures `localhost`: (bis Docker 1.8)
							- `--link` und Volumes nur auf lokalem Host
							- Kein cross-host Netzwerk

							##### Add-on Tools
							- Unübersichtliches, dynamisches Ökosystem   <!-- -->
							- Sehr oft nur Einzelteile einer Gesamtlösung
							- Eher fragil; volles Verständnis notwendig
						</div>
					</section>

					<!--
					<section>
						<div class="container sm"  data-markdown>
							## Übersicht Ökosystem

							| Kategorie          | Tools |
							|--------------------|-------|
							| Container/Host OS  | CoreOS, RancherOS, Snappy Ubuntu, ...   |
							| Config Mgmt.  	 | Puppet, Chef, Ansible, Capistrano, ...  |
							| Container Grouping | Docker Compose, Kubernetes, Maestro, crane |
							| Image Registry     | Docker Distribution, Artifactory, ...  |
							| Networking         | Weave, Flannel, Skydock, ... |
							| Service Discovery  | etcd, Consul, Zookeeper, ... |
							| Scheduler          | fleet, Marathon/Mesos, Docker Swarm |
							| Cluster Mgmt.      | Shipyard, MaestroNG, **Rancher** |
						</div>
					</section>
				-->

					<section>
						<h2>Tools</h2>

						<img src="img/logos/mesos_400x400.png" alt="Mesos" class="glow plain" width=200>
						<img src="img/logos/marathon.png" alt="Marathon" class="glow plain" width=200>
						<img src="img/logos/aurora_400x400.png"  alt="Aurora" class="glow plain" width=200>
					  <br>
						<img src="img/logos/rancher_400x400.png"  alt="Rancher" class="glow plain" width=200>
						<img src="img/logos/kubernetes.png"  alt="Kubernetes" class="glow plain" width=200>
						<img src="img/logos/swarm.png"  alt="Docker Swarm" class="glow plain" width=200>
					  <br>
						<img src="img/logos/weave.png"  alt="Weaveworks" class="glow plain" width=200>

						<aside class="notes" data-markdown>
							- Mesos + Marathon/Aurora
							- Kubernetes
							- Rancher
							- Docker Machine/Compose/Swarm (BETA)
							- Weaveworks
						</aside>
					</section>

					<section data-background-video="video/rancher-demo.webm" data-state="webm-video">
	        </section>

					<section>
						<h2>Beispiel - verteiltes System</h2>
						<img src="img/verteilt.png" class="plain" width="600">
						<aside class="notes" data-markdown>
							Vereiltes System aus
							- load balancer 1x
							- web/rest-Knoten 1..n
							- Message Queue 1x
							- Worker 1..m
							- Datenbank 1x

							Jeder Kasten ein Docker-Container:
							- Rot: leicht skalierbar, gut im Cluster zu verteilen
							- Grün: eher ausserhalb wegen Erreichbarkeit (LB) oder Datenhaltung (DB)
						</aside>
					</section>
				</section>

				<!--
				#######################################################################################################
					Hype vs. Potential
				#######################################################################################################
				-->

				<section>
					<section class="toc-element">
						<h1>Hype vs. Potential</h1>
					</section>

					<section>
						<h2>Docker &amp; Windows</h2>

						<div class="container">
							<img class="plain" data-src="img/boot2docker.png" alt="boot2docker logo"/>
							<div style="float: right; margin-left: 60px; " data-markdown>
								##### Heute: (Linux container)
								- boot2docker
								- Docker auf Microsoft Azure

								##### Zukunft: (Windows container)
								- Windows Server Containers
								- Hyper-V Container
							</div>
						</div>

						<aside class="notes" data-markdown>
							- Einstieg auch auf Windows: boot2docker sehr komfortabel. Startet eine Virtualbox in
							  welcher die Container laufen.
							- Nicht auf Linux beschränkt. Microsoft arbeitet bereits eng mit Docker zusammen:
							    - Ein windows Docker client gibt es bereits: Deployment von Linux VMs
								- Auf Azure kann man Linux Container starten
								- Docker-Anbindung an Windows-Server-Containern und Hyper-V-Containern auf dem Weg
						</aside>
					</section>


					<section>
						<div class="container">
							<div style="text-align: right; margin: 0 40px; float: left; margin-top: 140px ">
								<h2 class="emphasize">Status </h2>
								<h5 style="margin-top: -30px; color: #ccc;text-align: right;">von Docker</h5>
							</div>

							<div class="container"
								 style="border-left: 5px solid #42affa; margin: 0 120px 0 0">
								<ul>
									<li>nur Teil <span class="decent">einer Gesamtlösung</span></li>
									<li>Dynamisches Umfeld</li>
									<li>1.x-Technologie <span class="decent">&amp; Folgeprobleme</span></li>
									<li>Unklare Ausrichtung <br>
										<span class="decent">➱ Rocket, Open Container, LXD</span></li>
								</ul>
							</div>
						</div>

						<aside class="notes" data-markdown>
							- »Let’s Dockerize everything« ➱ ziemlich wild & übermütig
							- Brauche ich Docker?
								- Signifikante Vorteile von Container/speziell Docker?
								- Habe ich technische Ressourcen für komplexe, ungelöste Probleme?
							- Unklare Ausrichtung Docker führt zu Alternativen
						</aside>
					</section>

					<section>
						<div class="container">
							<div style="text-align: right; margin: 0 40px; float: left; margin-top: 140px ">
								<h2 class="emphasize">Fragen, </h2>
								<h5 style="margin-top: -30px; color: #ccc;">die sich durch Docker ergeben</h5>
							</div>

							<div class="container"
								 style="border-left: 5px solid #42affa; margin: 0 120px 0 0">
								<ul>
									<li>Nachvollziehbarkeit
										<span class="decent"><br>&amp; Delivery Model</span></li>
									<li>Datenhaltung</li>
									<li>Zuständigkeiten</li>
									<li>Security <span class="decent">(root, Patches)</span></li>
								</ul>
							</div>
						</div>

						<aside class="notes" data-markdown>
							- Delivery Model: Binary Blob oder Dockerfile? Wie nachvollziehbar?
							- Datenhaltung: Kein Koch-Rezept hier. Fokus = Immutable infrastructure
							- Docker images == platform-specific binaries
							- Zuständigkeit: Operations oder Developer
							- Security
							    - docker === root; normalerweise daher auch immer `sudo docker`
							    - Gestackte Images -> Viele ungeupdate Basisimages
							    - (Security) Patch Strategie & Support
						</aside>
					</section>

					<section>
						<h2>Potential Docker</h2>
						<div class="container">

						<div class="twocol" style="margin: 0 0 0 32px;">
							<img data-src="img/docker-benefits-build.png" alt="Build Umgebung" class="floaticon plain" />
							<p class="floaticon">
								<strong>Automatisierung</strong>
								<span class="decent sm">Provisioning,&nbsp;Config,&nbsp;Delivery</span>
							</p>

							<img data-src="img/docker-benefits-nosetup.png" alt="Kein Setup" class="floaticon plain" />
							<p class="floaticon tgap">
								<strong>Immutability</strong><br>
								<span class="decent sm">Umgebung = Code. Disposable</span>
							</p>
						</div>
						<div class="twocol" style="">
							<img data-src="img/docker-benefits-consolidate.png" alt="Konsolidierung" class="floaticon plain" />
							<p class="floaticon">
								<strong>Serverkonsolidierung</strong><br>
								<span class="decent sm">System-agnostisch</span>
							</p>

							<img data-src="img/docker-benefits-deploy.png" alt="Schnelleres Deployment" class="floaticon plain tgap" />
							<p class="floaticon tgap">
								<strong>Deployment</strong><br>
								<span class="decent sm">Einfach; Container als Einheit</span>
							</p>
							</div>
						</div>

						<div class="fragment decent" >
							<div data-markdown class="sm" style="border-top: 5px solid #42affa; margin: 16px auto 0; padding: 32px 0 0 0 ;">
								#### Brauche ich Docker?
								- Was sind signifikante Vorteile?
								- Ressourcen für komplexe, ungelöste Probleme?
							</div>

							<div data-markdown class="container emphasize">
								_»Let’s Dockerize everything«_ ➱ ziemlich wild & übermütig!
							</div>
						</div>

						<aside class="notes" data-markdown>
						#### Automatisierung:
						- Automatiiserung Systembereitstellung, Configuration & Delivery

						#### Immutability

						- Konfiguration = Code. Setup entfällt

						#### Serverkonsolidierung:

						- It can get more applications running on the same hardware than other technologies; it makes it easy for developers to quickly create, ready-to-run containered applications; and it makes managing and deploying applications much easier.
						- System-agnostisch
						- Instanz & Server damit Wegwerfware

						#### Deployment:

						- vereinfacht Bereitstellung
						- Container = Baustein für komplexe Infrastrukturen
						- Applikationszentriert statt Infrastruktur-Zentrierte Sicht
						</aside>
					</section>

				</section>


				<section
					style="background: rgba(0,0,0,.6)"
					data-background="https://33.media.tumblr.com/fff297fe7db149b209e91cfbca70acd0/tumblr_mi6xc7l6Be1s5ys1do1_500.gif"
					data-background-transition="zoom">
					<h2>Tools</h2>

					<div class="container" style="font-size: 68%;width: 90%; line-height: 1.1em;">
						<div data-markdown class="col3-l">
							###### GUIs
							- Docker [Kitematic](https://kitematic.com/)
							- [Panamax](http://panamax.io/), ...

							##### Spezielle Linux-Distros
							- [RancherOS](http://rancher.com/rancher-os/)
							- [CoreOS](https://coreos.com/), ...

 							###### Private Image Registry
							- Docker [Distribution](https://github.com/docker/distribution)
							- [Artifactory](http://www.jfrog.com/open-source/), ...

							###### Networking
							- [Weaveworks](http://weave.works/)
							- CoreOS [Flannel](https://github.com/coreos/flannel), ...
						</div>

						<div data-markdown class="col3-c">
							###### Service discovery
							- CoreOS [etcd](https://github.com/coreos/etcd)
							- Apache [Zookeeper](https://zookeeper.apache.org/)
							- [Consul](https://www.consul.io/)

							###### Cluster / Orchestrierung
							- [Rancher](http://rancher.com/rancher-io/)
							- [Kubernetes](http://kubernetes.io/)
							- [Shipyard](http://shipyard-project.com/)
							- Docker [Compose](https://docs.docker.com/compose/) / [Swarm](http://docs.docker.com/swarm/)
							- Apache [Mesos](http://mesos.apache.org/) / [Marathon](https://mesosphere.github.io/marathon/)
							- [MaestroNG](https://github.com/signalfuse/maestro-ng)
							- CoreOS [fleet](https://github.com/coreos/fleet), ...
						</div>

						<div data-markdown  class="col3-r">
							###### Config Mgmt.
							- [Ansible](http://www.ansible.com/)
							- [Puppet](https://puppetlabs.com/)
							- [Chef](https://www.chef.io/)
							- [Capistrano](http://capistranorb.com/)

							###### Interessante Java-Tools
							- [Dropwizard](http://dropwizard.io)
							- [Spark](http://sparkjava.com)
							- [Vert.x](http://vertx.io)
							- [Spring Boot](http://http://projects.spring.io/spring-boot)
							- [Docker Maven-Plugins](https://github.com/alexec/docker-maven-plugin/blob/master/COMPETITORS.md)
						</div>

						<div style="clear:both"/>

						<div data-markdown style="font-size: 0.6em; color: #666; padding: 20px 0;">
							Image Credits:
							_Southampton Container Port_
							[Geni](http://commons.wikimedia.org/wiki/File:Southampton_container_port_2_ships.JPG) /
							[CC-BY-SA-4.0](https://creativecommons.org/licenses/by-sa/4.0/),
							_Blades_
							[zagrobot](https://www.flickr.com/photos/zagrobot/2731084578)
							[CC-BY-2.0](https://creativecommons.org/licenses/by/2.0/)
						</div>
					</div>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				// Display controls in the bottom right corner
			    controls: true,

			    // Display a presentation progress bar
			    progress: true,

			    // Display the page number of the current slide
			    slideNumber: false,

			    // Push each slide change to the browser history
			    history: true,

			    // Enable keyboard shortcuts for navigation
			    keyboard: true,

			    // Enable the slide overview mode
			    overview: true,

			    // Vertical centering of slides
			    center: true,

			    // Enables touch navigation on devices with touch input
			    touch: true,

			    // Loop the presentation
			    loop: false,

			    // Change the presentation direction to be RTL
			    rtl: false,

			    // Turns fragments on and off globally
			    fragments: true,

			    // Flags if the presentation is running in an embedded mode,
			    // i.e. contained within a limited portion of the screen
			    embedded: false,

			    // Flags if we should show a help overlay when the questionmark
			    // key is pressed
			    help: true,

			    // Number of milliseconds between automatically proceeding to the
			    // next slide, disabled when set to 0, this value can be overwritten
			    // by using a data-autoslide attribute on your slides
			    autoSlide: 2000,

			    // Stop auto-sliding after user input
			    autoSlideStoppable: true,

			    // Enable slide navigation via mouse wheel
			    mouseWheel: true,

			    // Hides the address bar on mobile devices
			    hideAddressBar: true,

			    // Opens links in an iframe preview overlay
			    previewLinks: true,

			    // Transition style
			    transition: 'slide', // none/fade/slide/convex/concave/zoom

			    // Transition speed
			    transitionSpeed: 'default', // default/fast/slow

			    // Transition style for full page slide backgrounds
			    backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

			    // Number of slides away from the current that are visible
			    viewDistance: 3,

			    // Parallax background image
			    parallaxBackgroundImage: 'img/southampton_container_port_2_ships.jpg', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

			    // Parallax background size
			    parallaxBackgroundSize: '3874px 2100px', // CSS syntax, e.g. "2100px 900px"

			    // Amount to move parallax background (horizontal and vertical) on slide change
			    // Number, e.g. 100
			    parallaxBackgroundHorizontal: '',
			    parallaxBackgroundVertical: '',

				// The "normal" size of the presentation, aspect ratio will be preserved
			    // when the presentation is scaled to fit different resolutions. Can be
			    // specified using percentage units.
			    width: 1280,
			    height: 720,

			    // Factor of the display size that should remain empty around the content
			    margin: 0.05,

			    // Bounds for smallest/largest possible scale to apply to content
			    minScale: 0.2,
			    maxScale: 1.5,

				// Ctrl + Mouse-Click ==> Zoom in
				zoomKey: 'ctrl',

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

			Reveal.addEventListener( 'webm-video', function() {
				var videoElems = document.getElementsByTagName("VIDEO");
    			if (videoElems && videoElems.length > 0) {
					videoElems[0].playbackRate = 3.0;
				}
			} );

		</script>


		<script src="js/zepto.min.js"></script>
		<script>
		    Zepto(function ($) {

		        var tableOfContents = $('#table-of-contents');
		        var tableList = $('<ol />')

		        $('.toc-element').each(function (index) {
		            var _self = $(this),
		                    hash = '#/' + _self.closest('section').index();

		            if (_self.text()) tableList.append([
		                '<li>',
		                    //    '<a href="' + hash + '">',
		                _self.text(),
		                	//'</a>',
		                '</li>'
		            ].join(''));

		        });

		        tableOfContents.html(tableList);
		    });
		</script>

	</body>
</html>
